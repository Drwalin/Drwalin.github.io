
			
<table>
  <tr>
    <th>Company</th>
    <th>Contact</th>
    <th>Country</th>
  </tr>
  <tr>
    <td>Krowodajnia</td>
    <td>Texas</td>
    <td>USA</td>
  </tr>
  <tr>
    <td>Ziemniaczarnia</td>
    <td>Jan Kowalski</td>
    <td>Lechia</td>
  </tr>
  <tr>
    <td>Masarnia</td>
    <td>Алоша Цернов</td>
    <td>Russia</td>
  </tr>
  <tr>
    <td>Glukozodajnia</td>
    <td>sklep</td>
    <td>Canada</td>
  </tr>
</table>
			
			<br /><br />
			
			
			
			
			
			
			
			
			<?prettify linenums=311?>
		<pre class="prettyprint">
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )		// Some arguments to expand the width of code highlight box
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}
void Buffer::ClearWorkingArea( const char sign, const uint8 frontColor, const uint8 backgroundColor )
{
	uint8 color = ( backgroundColor << uint8(4) ) + frontColor;
	if( consoleBuffer )
	{
		for( uint32 x = workAreaMin.x; x < workAreaMax.x; ++x )
		{
			for( uint32 y = workAreaMin.y; y < workAreaMax.y; ++y )
			{
				consoleBuffer[ x + size.x*y ].asciiChar = sign;
				consoleBuffer[ x + size.x*y ].attributes = color;
			}
		}
	}
	else
	{
		// TODO:
		//	Error handling;
	}
}</pre>
			
			<br />
			
			
			